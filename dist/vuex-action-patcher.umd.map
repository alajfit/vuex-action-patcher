{"version":3,"sources":["utils/isPromise/index.js","utils/patchAction/index.js","utils/patchModule/index.js","utils/index.js","index.js"],"names":["isPromise","val","then","patchAction","store","type","handler","local","tools","entry","_actions","length","pop","push","payload","cb","context","Object","assign","dispatch","commit","getters","state","rootGetters","rootState","res","utils","Promise","resolve","_devtoolHook","catch","err","emit","patchModule","path","module","namespace","_modules","getNamespace","forEachAction","action","key","forEachChild","child","concat","vuexActionPatcher","Vuex","copyRegisterModule","Store","prototype","registerModule","root","rawModule","call","get"],"mappings":"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","file":"vuex-action-patcher.umd.map","sourceRoot":"../src","sourcesContent":["export default function isPromise (val) {\n    return val && typeof val.then === 'function'\n}\n","import utils from '../index'\n\nexport default function patchAction ({\n    store,\n    type,\n    handler,\n    local,\n    tools\n}) {\n    const entry = store._actions[type] || (store._actions[type] = [])\n\n    if (entry.length > 0) entry.pop()\n\n    entry.push((payload, cb) => {\n        let context = Object.assign({\n            dispatch: local.dispatch,\n            commit: local.commit,\n            getters: local.getters,\n            state: local.state,\n            rootGetters: store.getters,\n            rootState: store.state\n        }, tools)\n        let res = handler(context, payload, cb)\n\n        if (!utils.isPromise(res)) res = Promise.resolve(res)\n        return store._devtoolHook\n            ? res.catch(err => {\n                store._devtoolHook.emit('vuex:error', err)\n                throw err\n            })\n            : res\n    })\n}\n","import utils from '../index'\n\n/**\n * @name patchModule\n * @description Used Initiate the patching of Actions and patching of sub modules\n * @param {*} param0\n */\nexport default function patchModule ({\n    store,\n    path,\n    module,\n    tools\n}) {\n    const namespace = store._modules.getNamespace(path)\n    const local = module.context\n\n    // Patch the current Actions context for this module\n    module.forEachAction((action, key) => utils.patchAction({\n        store,\n        type: (namespace + key),\n        handler: action,\n        local,\n        tools\n    }))\n\n    // Setup child modules for action patch\n    module.forEachChild((child, key) => patchModule({\n        store,\n        path: path.concat(key),\n        module: child,\n        tools\n    }))\n}\n","import isPromise from './isPromise'\nimport patchAction from './patchAction'\nimport patchModule from './patchModule'\n\nexport default {\n    isPromise,\n    patchAction,\n    patchModule\n}\n","import utils from './utils'\n\n/**\n * @name vuexActionPatcher\n * @desc Patch the main state and all registered submodules\n * @param tools An { object } of tools to be added to the Vuex context\n */\nexport default function vuexActionPatcher (Vuex, tools = {}) {\n    return store => {\n        // Taking a copy of the original registerModule function\n        const copyRegisterModule = Vuex.Store.prototype.registerModule\n\n        // Patch the Core Module\n        utils.patchModule({\n            store,\n            path: [],\n            module: store._modules.root,\n            tools\n        })\n\n        // Patch Modules registered later\n        Vuex.Store.prototype.registerModule = function registerModule (path, rawModule) {\n            copyRegisterModule.call(this, path, rawModule)\n            utils.patchModule({\n                store: this,\n                path: [].concat(path),\n                module: this._modules.get([path]),\n                tools\n            })\n        }\n    }\n}\n"]}