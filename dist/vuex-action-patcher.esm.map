{"version":3,"sources":["utils/isPromise/index.js","utils/patchAction/index.js","utils/patchModule/index.js","utils/index.js","index.js"],"names":["isPromise","val","then","patchAction","store","type","handler","local","entry","_actions","length","pop","push","payload","cb","res","dispatch","commit","getters","state","rootGetters","rootState","utils","Promise","resolve","_devtoolHook","catch","err","emit","patchModule","path","module","hot","namespace","_modules","getNamespace","context","forEachAction","action","key","forEachChild","child","concat","vuexActionPatcher","Vuex","tools","root","orig","Store","prototype","registerModule","rawModule","call","get"],"mappings":";AAEC,aAFc,SAASA,EAAWC,GACxBA,OAAAA,GAA2B,mBAAbA,EAAIC,KAC5B,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,QAAA;;AC8BA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,QAAA,EAhCD,IAAA,EAAA,EAAA,QAAA,aAgCC,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GA9Bc,SAASC,GAAa,MACjCC,EADiC,KAEjCC,EAFiC,QAGjCC,EAHiC,MAIjCC,IAEMC,MAAAA,EAAQJ,EAAMK,SAASJ,KAAUD,EAAMK,SAASJ,GAAQ,IAE1DG,EAAME,OAAS,GAAGF,EAAMG,MAE5BH,EAAMI,KAAK,SAA+BC,EAASC,GAC3CC,IAAAA,EAAMT,EAAQ,CACdU,SAAUT,EAAMS,SAChBC,OAAQV,EAAMU,OACdC,QAASX,EAAMW,QACfC,MAAOZ,EAAMY,MACbC,YAAahB,EAAMc,QACnBG,UAAWjB,EAAMe,OAClBN,EAASC,GAGRV,OADCkB,EAAMtB,QAAAA,UAAUe,KAAMA,EAAMQ,QAAQC,QAAQT,IAC7CX,EAAMqB,aACCV,EAAIW,MAAMC,IAEPA,MADNvB,EAAMqB,aAAaG,KAAK,aAAcD,GAChCA,IAGHZ;;ACNlB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,QAAA,EAvBD,IAAA,EAAA,EAAA,QAAA,aAuBC,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GArBc,SAASc,GAAa,MACjCzB,EADiC,KAEjC0B,EAFiC,OAGjCC,EAHiC,IAIjCC,IAEMC,MAAAA,EAAY7B,EAAM8B,SAASC,aAAaL,GACxCvB,EAAQwB,EAAOK,QAErBL,EAAOM,cAAc,CAACC,EAAQC,IAAQjB,EAAMnB,QAAAA,YAAY,CACpDC,MAAAA,EACAC,KAAO4B,EAAYM,EACnBjC,QAASgC,EACT/B,MAAAA,KAEJwB,EAAOS,aAAa,CAACC,EAAOF,IAAQV,EAAY,CAC5CzB,MAAAA,EACA0B,KAAMA,EAAKY,OAAOH,GAClBR,OAAQU,EACRT,IAAAA;;ACjBO,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAJf,IAAA,EAAA,EAAA,QAAA,gBACA,EAAA,EAAA,QAAA,kBACA,EAAA,EAAA,QAAA,kBAEe,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,IAAA,EAAA,CACXhC,UAAAA,EADW,QAEXG,YAAAA,EAFW,QAGX0B,YAAAA,EAAAA,SAHW,QAAA,QAAA;;ACmBd,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,QAAA,EAvBD,IAAA,EAAA,EAAA,QAAA,YAuBC,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAhBc,SAASc,EAAmBC,EAAMC,GACtCzC,OAAAA,IAEGyB,EAAAA,QAAAA,YAAY,CACdzB,MAAAA,EACA0B,KAAM,GACNC,OAAQ3B,EAAM8B,SAASY,KACvBd,IAAK,OAGHe,MAAAA,EAAOH,EAAKI,MAAMC,UAAUC,eAClCN,EAAKI,MAAMC,UAAUC,eAAiB,SAAyBpB,EAAMqB,GACjEJ,EAAKK,KAAK,KAAMtB,EAAMqB,GAChBtB,EAAAA,QAAAA,YAAY,KAAM,GAAGa,OAAOZ,GAAO,KAAKI,SAASmB,IAAI,CAACvB","file":"vuex-action-patcher.esm.map","sourceRoot":"../src","sourcesContent":["export default function isPromise (val) {\n    return val && typeof val.then === 'function'\n}\n","import utils from '../index'\n\nexport default function patchAction ({\n    store,\n    type,\n    handler,\n    local\n}) {\n    const entry = store._actions[type] || (store._actions[type] = [])\n\n    if (entry.length > 0) entry.pop()\n\n    entry.push(function wrappedActionHandler (payload, cb) {\n        let res = handler({\n            dispatch: local.dispatch,\n            commit: local.commit,\n            getters: local.getters,\n            state: local.state,\n            rootGetters: store.getters,\n            rootState: store.state\n        }, payload, cb)\n\n        if (!utils.isPromise(res)) res = Promise.resolve(res)\n        if (store._devtoolHook) {\n            return res.catch(err => {\n                store._devtoolHook.emit('vuex:error', err)\n                throw err\n            })\n        } else {\n            return res\n        }\n    })\n}\n","import utils from '../index'\n\nexport default function patchModule ({\n    store,\n    path,\n    module,\n    hot\n}) {\n    const namespace = store._modules.getNamespace(path)\n    const local = module.context\n\n    module.forEachAction((action, key) => utils.patchAction({\n        store,\n        type: (namespace + key),\n        handler: action,\n        local\n    }))\n    module.forEachChild((child, key) => patchModule({\n        store,\n        path: path.concat(key),\n        module: child,\n        hot\n    }))\n}\n","import isPromise from './isPromise'\nimport patchAction from './patchAction'\nimport patchModule from './patchModule'\n\nexport default {\n    isPromise,\n    patchAction,\n    patchModule\n}\n","import utils from './utils'\n\n/**\n * @name vuexActionPatcher\n * @desc Patch the main state and all registered submodules\n * @param tools An { object | array } of tools to be added to the Vuex context\n */\nexport default function vuexActionPatcher (Vuex, tools) {\n    return store => {\n        // Patch the original store\n        utils.patchModule({\n            store,\n            path: [],\n            module: store._modules.root,\n            hot: null\n        })\n        // Augment the registerModule to add tools\n        const orig = Vuex.Store.prototype.registerModule\n        Vuex.Store.prototype.registerModule = function registerModule (path, rawModule) {\n            orig.call(this, path, rawModule)\n            utils.patchModule(this, [].concat(path), this._modules.get([path]))\n        }\n    }\n}\n"]}